<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://d3js.org/d3-time.v1.min.js"></script>
  <script src="https://d3js.org/d3-time-format.v2.min.js"></script>
  <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
  <style>

  .area {
    fill: steelblue;
    clip-path: url(#clip);
  }

  .zoom {
    cursor: move;
    fill: none;
    pointer-events: all;
  }

   div.tooltip {
      position: absolute;
      text-align: center;
      width: 120px;
      height: 120px;
      padding: 2px;
      font: 12px sans-serif;
      background: lightsteelblue;
      border: 0px;
      border-radius: 8px;
      pointer-events: none;
    }


.bar text {
  fill: purple;
  font: 15px sans-serif;
}
  </style>
</head>

<body>
  <script>

var margin = {
              top: 20,
              right: 60,
              bottom: 50,
              left: 30,
                };

var width = 1400;
var height = 1000;
var w1 = 0.7 * width - margin.left - margin.right
var h1 = 0.8 * height - margin.top - margin.bottom
var w2 = 0.7 * width - margin.left - margin.right
var h2 = 0.2 * height - margin.top - margin.bottom
var w3 = 0.3 * width - margin.left - margin.right
var h3 = 0.4 * height - margin.top - margin.bottom

var parseUTCDateHour = d3.timeParse("%Y-%m-%dT%H:%M%Z");
var parseUTCDate = d3.timeParse("%Y-%m-%d");
var parseUTCDate2 = d3.timeParse("%W-%m-%Y");

// Define the div for the tooltip
var div = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0);

var svg = d3.select("body")
                  .append("svg")
                  .attr("width", width)
                  .attr("height", height)
                  .append("g")

// y scale
var y1 = d3.scaleLinear()
          .domain([0,24])
          .range([0,h1]);

var y2 = d3.scaleLinear()
          .domain([0,600])
          .range([h2,0]);

// x scale

var x1 = d3.scaleTime()
          .range([0, w1]);

var x2 = d3.scaleTime()
          .range([0, w2]);

var y3 = d3.scaleLinear()
            .rangeRound([0,h3]);

// X absis
var xAxis1 = d3.axisBottom()
            .scale(x1);

var xAxis2 = d3.axisBottom()
            .scale(x2);

function sortByDateAscending(a, b) {
    // Dates will be cast to numbers automagically:
    return (parseUTCDate2(a.key) - parseUTCDate2(b.key));
}


var focus = svg.append("g")
    .attr("class", "focus");

var context = svg.append("g")
    .attr("class", "focus");

var data =  d3.json("short_flat_messages.json", function(json){

  // Create the SVG

  // moves the 'group' element to the top left margin
  svg.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  // Parse the Date
  getDate = function(date){
    string = date.getFullYear() + "-" + date.getMonth() + "-" + date.getDate();
    return parseUTCDate(string);
  }

  getTime = function(date){ //Remove the ":" in order to match the correct format
    return date.getHours() + date.getMinutes()/60;
  };

  json.data.forEach(function(element){
    date = element.date
    date = parseUTCDateHour(date.substring(0, date.length - 3) + date.substring(date.length - 2, date.length))
    element.time = getTime(date);
    element.date = getDate(date);
  });

  var mindate_total = d3.min(json.data, function(d){return d.date}),
      maxdate_total = d3.max(json.data, function(d){return d.date});

  x1.domain([mindate_total, maxdate_total]);
  x2.domain([mindate_total, maxdate_total]);

function create_scatterplot(data_sca, max_date ,min_date){

  focus.selectAll('circle.message')
                        .remove();

  focus.selectAll("circle.message")
    .data(data_sca.filter(function(element){
        return (element.date < max_date && element.date > min_date);
    }))
      .enter()
      .append("circle")
      .attr("class" , "message")
      .attr("fill", function(element){
        if (element.sender == "Mathilde Reynaud"){
          return "blue";
        }
        else
        {
          return "purple";
        }})
      .attr("cx", function(element){return x1(element.date);})
      .attr("cy", function(element){return y1(element.time);})
      .attr('fill-opacity', 0.2)
      .attr("r", 2)
      .on("mouseover", function(element) {
        div.transition()
            .duration(200)
            .style("opacity", .9);
        div.html(element.date + "<br/>"  + element.sender)
            .style("left", (d3.event.pageX) + "px")
            .style("top", (d3.event.pageY - 28) + "px");
        })
      .on("mouseout", function(element) {
        div.transition()
            .duration(500)
            .style("opacity", 0);
      });

}

create_scatterplot(json.data, maxdate_total, mindate_total);

  focus.append('g')
    .attr('transform', 'translate(0,' + h1 + ')')
    .attr('class', 'x axis--x')
    .call(xAxis1);

Date.prototype.getWeek = function() {
    var date = new Date(this.getTime());
     date.setHours(0, 0, 0, 0);
    // Thursday in current week decides the year.
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    // January 4 is always in week 1.
    var week1 = new Date(date.getFullYear(), 0, 4);
    // Adjust to Thursday in week 1 and count number of weeks from date to week1.
    return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000
                          - 3 + (week1.getDay() + 6) % 7) / 7);
  }

  var nested_data = d3.nest().key(function(d){
    return d.date.getWeek() + '-' + d.date.getMonth() + '-' + d.date.getFullYear();})
    .rollup(function(leaves) {
        return  leaves.length
    })
    .entries(json.data);

nested_data = nested_data.sort(sortByDateAscending);

var max_message = d3.max(nested_data, function(d){return d.value});

y2.domain([0, max_message]);

var area = d3.area()
    .curve(d3.curveBasisOpen)
    .x(function(d) { return x2(parseUTCDate2(d.key));})
    .y0(h2)
    .y1(function(d) { return y2(d.value); });


focus.append("path")
      .datum(nested_data)
      .attr("class", "area")
      .attr("d", area)
      .attr('transform', 'translate(0,' + (h1 + 2*margin.top + margin.bottom) + ')')

context.append('g')
    .attr('transform', 'translate(0,' + (h2 + h1 + 2*margin.top + margin.bottom) + ')')
    .attr('class', 'x axis--x')
    .call(xAxis2);

function draw_histogram(data_hist, max_date, min_date){

  svg.selectAll('.bar')
      .remove();

  svg.selectAll('.y_hist')
      .remove();

  var nested_data_hist = d3.nest().key(function(d){
    return d.date;  })
    .rollup(function(leaves) {
        return  leaves.length
    })
    .entries(data_hist.filter(function(element){
        return (element.date < max_date && element.date > min_date);
    }));
  //  .map(function(d){
  //    return d.value;});
  var min_num = d3.min(nested_data_hist, function(d){return d.value}),
      max_num = d3.max(nested_data_hist, function(d){return d.value});

  y3.domain([min_num,max_num]);

  var histogram = d3.histogram()
      .value(function(d) {return +d.value;})
      .domain(y3.domain())
      .thresholds(y3.ticks(20));

  var bins = histogram(nested_data_hist);

  var x3 = d3.scaleLinear()
      .domain([0, d3.max(bins, function(d) { return d.length; })])
      .range([0, w3]);

  var bar = svg.selectAll(".bar")
    .data(bins)
    .enter().append("g")
      .attr("class", "bar")
      .attr("transform", function(d) { return "translate(" + 0 + "," + y3(d.x0) + ")"; });

  var clicked_rect = null;

  bar.append("rect")
      .style("fill", "steelblue")
      .attr("y", 1)
      .attr("height", y3(bins[0].x1) - y3(bins[0].x0) - 1)
      .attr("width", function(d) {return x3(d.length); })
      .attr("transform", "translate(" + (w1 + margin.right + margin.left) + "," + margin.top + ")")
      .on ("click", function(d){
          d3.selectAll("circle.message")
          .attr('fill-opacity', 0.2);

          d3.selectAll("g")
            .selectAll(".bar")
            .selectAll("rect")
            .style("fill","steelblue");

        if (clicked_rect !== d){

          d3.select(this)
            .style("fill", "purple");

          d3.selectAll("circle.message")
          .attr('fill-opacity', 0);

              for (var i=0;  i < d.length; i++ ){
                  d3.selectAll("circle.message")
                    .filter(function(e) {
                        return e.date == d[i].key;
                              })
                    .attr('fill-opacity', 0.2);
          }
            clicked_rect = d;
        }
        else {
        clicked_rect = null;
        }

      });

  bar.append("text")
      .attr("dy", ".75em")
      .attr("y", 6)
      .attr("x", function(d) { return x3(d.length) + 12 ; })
      .attr("text-anchor", "middle")
      .text(function(d) { return d.length; })
      .attr("transform", "translate(" + (w1 + margin.right + margin.left) + "," + margin.top + ")");

  svg.append("g")
      .attr("class", "y_hist")
      .attr("transform", "translate(" + (w1 + margin.right + margin.left) + "," + margin.top + ")")
      .call(d3.axisLeft(y3));

}

draw_histogram(json.data, maxdate_total, mindate_total);
  //
/* bar.append("text")
    .attr("dy", ".75em")
    .attr("y", 6)
    .attr("x", (x3(bins[0].x1) - x3(bins[0].x0)) / 2)
    .attr("text-anchor", "middle")
    .text(function(d) { return formatCount(d.length); }); */

/*  svg.append("rect")
      .attr("class", "zoom")
      .attr("width", width)
      .attr("height", height)
      .attr("transform", "translate(" + margin.left + "," + (h1 + margin.top) + ")")
      .call(zoom);
*/

  function brushed() {
      if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom"){return;}; // ignore brush-by-zoom
      var s = d3.event.selection || x2.range();
      x1.domain(s.map(x2.invert, x2));


      create_scatterplot(json.data, x1.domain()[1], x1.domain()[0]);
      if (x1.domain()[1] > x1.domain()[0]) {
          draw_histogram(json.data, x1.domain()[1], x1.domain()[0]);
          }
      else {
          draw_histogram(json.data, x1.domain()[0], x1.domain()[1])
      }


      focus.select(".axis--x").call(xAxis1);
      svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
          .scale(width / (s[1] - s[0]))
          .translate(-s[0], 0));

        }

  function zoomed() {
      if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") {return;}; // ignore zoom-by-brush
      var t = d3.event.transform;
      x1.domain(t.rescaleX(x2).domain());

      create_scatterplot(json.data, x1.domain()[1], x1.domain()[0]);

      create_scatterplot(json.data, x1.domain()[1], x1.domain()[0]);
      if (x1.domain()[1] > x1.domain()[0]) {
          draw_histogram(json.data, x1.domain()[1], x1.domain()[0]);
          }
      else {
          draw_histogram(json.data, x1.domain()[0], x1.domain()[1])
      }

      focus.select(".axis--x").call(xAxis1);
      context.select(".brush").call(brush.move, x1.range().map(t.invertX, t));
  }

  var brush = d3.brushX()
      .extent([[0, h1 + 2*margin.top + margin.bottom], [w2, h1 + 2*margin.top + margin.bottom + h2]])
      .on("brush start", brushed)
      .on("brush end", brushed);

  var zoom = d3.zoom()
    .scaleExtent([1, Infinity])
    .translateExtent([[0, h1 + 2*margin.top + margin.bottom], [w2, h1 + 2*margin.top + margin.bottom + h2]])
    //.translateExtent([[0, 0], [w1, h1]])
    .extent([[0, h1 + 2*margin.top + margin.bottom], [w2, h1 + 2*margin.top + margin.bottom + h2]])
    //.extent([[margin.left, margin.top], [margin.left + w1, margin.top + h1]])
    .on("zoom", zoomed);

  context.append("g")
        .attr("class", "brush")
        .call(brush)
        .call(brush.move, x2.range());

 });



  </script>
</body>
